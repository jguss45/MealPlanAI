{"ast":null,"code":"import { PDFDocument, rgb, StandardFonts, PageSizes } from 'pdf-lib';\nexport async function generatePDF(mealPlan) {\n  const pdfDoc = await PDFDocument.create(); // Create a new PDF document\n  const {\n    width,\n    height\n  } = PageSizes.A4; // Get the width and height of the A4 page\n  const pageMargin = 50; // Set the margin for the page\n  const lineHeight = 18; // Set the line height for the text\n  const maxLinesPerPage = Math.floor((height - 2 * pageMargin) / lineHeight); // Calculate the maximum lines that can fit on a page\n\n  const pageContents = mealPlan.split('\\n'); // Split the mealPlan into individual lines\n  let linesRemaining = maxLinesPerPage; // Initialize the number of lines remaining on the current page\n  let currentPage = pdfDoc.addPage([width, height]); // Add a new page to the PDF document\n  let yOffset = height - pageMargin; // Set the initial y-coordinate for drawing text on the page\n\n  const font = await pdfDoc.embedFont(StandardFonts.Helvetica); // Embed the Helvetica font into the PDF document\n\n  for (let i = 0; i < pageContents.length; i++) {\n    const line = pageContents[i].trim(); // Get the current line and remove leading/trailing whitespace\n\n    if (line === '') continue; // Skip empty lines\n\n    const words = line.split(' '); // Split the line into individual words\n    let lineChunks = ['']; // Initialize the line chunks array with an empty chunk\n    let currentLine = 0; // Initialize the current line index\n\n    for (let j = 0; j < words.length; j++) {\n      const word = words[j];\n      const currentChunk = lineChunks[currentLine];\n      if (currentChunk === '') {\n        lineChunks[currentLine] = word; // Add the word to the current chunk\n      } else {\n        const tempText = `${currentChunk} ${word}`;\n        const textSize = font.widthOfTextAtSize(tempText, lineHeight); // Get the width of the current chunk with the new word\n\n        if (textSize > width - 2 * pageMargin) {\n          currentLine++; // Move to the next line\n          lineChunks[currentLine] = word; // Start a new chunk with the word\n        } else {\n          lineChunks[currentLine] = tempText; // Add the word to the current chunk\n        }\n      }\n    }\n\n    if (linesRemaining - (currentLine + 1) < 0) {\n      currentPage = pdfDoc.addPage([width, height]); // Add a new page if the current page is full\n      yOffset = height - pageMargin; // Reset the y-coordinate for the new page\n      linesRemaining = maxLinesPerPage; // Reset the number of lines remaining on the new page\n    }\n\n    const formattedLines = lineChunks.filter(Boolean); // Remove empty chunks\n    const pageText = formattedLines.join('\\n'); // Join the formatted lines with newline characters\n    currentPage.drawText(pageText, {\n      x: pageMargin,\n      y: yOffset,\n      size: lineHeight,\n      font,\n      color: rgb(0, 0, 0)\n    }); // Draw the text on the current page\n\n    yOffset -= lineHeight * (currentLine + 1); // Update the y-coordinate for the next line\n    linesRemaining -= currentLine + 1; // Update the number of lines remaining on the current page\n  }\n\n  const pdfBytes = await pdfDoc.save(); // Save the PDF document as bytes\n  return pdfBytes; // Return the generated PDF bytes\n}","map":{"version":3,"names":["PDFDocument","rgb","StandardFonts","PageSizes","generatePDF","mealPlan","pdfDoc","create","width","height","A4","pageMargin","lineHeight","maxLinesPerPage","Math","floor","pageContents","split","linesRemaining","currentPage","addPage","yOffset","font","embedFont","Helvetica","i","length","line","trim","words","lineChunks","currentLine","j","word","currentChunk","tempText","textSize","widthOfTextAtSize","formattedLines","filter","Boolean","pageText","join","drawText","x","y","size","color","pdfBytes","save"],"sources":["C:/Users/joegu/OneDrive/Desktop/Projects/MealPlanAI/client/src/helpers/downloadMealPlan.js"],"sourcesContent":["import { PDFDocument, rgb, StandardFonts, PageSizes } from 'pdf-lib';\r\n\r\nexport async function generatePDF(mealPlan) {\r\n  const pdfDoc = await PDFDocument.create(); // Create a new PDF document\r\n  const { width, height } = PageSizes.A4; // Get the width and height of the A4 page\r\n  const pageMargin = 50; // Set the margin for the page\r\n  const lineHeight = 18; // Set the line height for the text\r\n  const maxLinesPerPage = Math.floor((height - 2 * pageMargin) / lineHeight); // Calculate the maximum lines that can fit on a page\r\n\r\n  const pageContents = mealPlan.split('\\n'); // Split the mealPlan into individual lines\r\n  let linesRemaining = maxLinesPerPage; // Initialize the number of lines remaining on the current page\r\n  let currentPage = pdfDoc.addPage([width, height]); // Add a new page to the PDF document\r\n  let yOffset = height - pageMargin; // Set the initial y-coordinate for drawing text on the page\r\n\r\n  const font = await pdfDoc.embedFont(StandardFonts.Helvetica); // Embed the Helvetica font into the PDF document\r\n\r\n  for (let i = 0; i < pageContents.length; i++) {\r\n    const line = pageContents[i].trim(); // Get the current line and remove leading/trailing whitespace\r\n\r\n    if (line === '') continue; // Skip empty lines\r\n\r\n    const words = line.split(' '); // Split the line into individual words\r\n    let lineChunks = ['']; // Initialize the line chunks array with an empty chunk\r\n    let currentLine = 0; // Initialize the current line index\r\n\r\n    for (let j = 0; j < words.length; j++) {\r\n      const word = words[j];\r\n      const currentChunk = lineChunks[currentLine];\r\n\r\n      if (currentChunk === '') {\r\n        lineChunks[currentLine] = word; // Add the word to the current chunk\r\n      } else {\r\n        const tempText = `${currentChunk} ${word}`;\r\n        const textSize = font.widthOfTextAtSize(tempText, lineHeight); // Get the width of the current chunk with the new word\r\n\r\n        if (textSize > width - 2 * pageMargin) {\r\n          currentLine++; // Move to the next line\r\n          lineChunks[currentLine] = word; // Start a new chunk with the word\r\n        } else {\r\n          lineChunks[currentLine] = tempText; // Add the word to the current chunk\r\n        }\r\n      }\r\n    }\r\n\r\n    if (linesRemaining - (currentLine + 1) < 0) {\r\n      currentPage = pdfDoc.addPage([width, height]); // Add a new page if the current page is full\r\n      yOffset = height - pageMargin; // Reset the y-coordinate for the new page\r\n      linesRemaining = maxLinesPerPage; // Reset the number of lines remaining on the new page\r\n    }\r\n\r\n    const formattedLines = lineChunks.filter(Boolean); // Remove empty chunks\r\n    const pageText = formattedLines.join('\\n'); // Join the formatted lines with newline characters\r\n    currentPage.drawText(pageText, {\r\n      x: pageMargin,\r\n      y: yOffset,\r\n      size: lineHeight,\r\n      font,\r\n      color: rgb(0, 0, 0),\r\n    }); // Draw the text on the current page\r\n\r\n    yOffset -= lineHeight * (currentLine + 1); // Update the y-coordinate for the next line\r\n    linesRemaining -= currentLine + 1; // Update the number of lines remaining on the current page\r\n  }\r\n\r\n  const pdfBytes = await pdfDoc.save(); // Save the PDF document as bytes\r\n  return pdfBytes; // Return the generated PDF bytes\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}